# 重载函数模板

考虑如下代码：

```cpp
template<class T>
int f(T){
    return 1;
}

template<class T>
int f(T*){
    return 2;
}
```

你要了解：这两个模板共同存在，且各自的实例化可以存在，尽管签名式一样

```cpp
int main(){
    std::cout<<f<int*>((int*)nullptr);	//call f<T>(T)
    std::cout<<f<int>((int*)nullptr);	//call f<T>(T*)
}
//12
```

稍作分析：

* f<int*>
  * f<int* >(int*)√
  * f<int*>(int**)

* f< int>
  * f<int>(int)
  * f< int>(int*)√

## 重载函数的选择决策

* 实参列表是否匹配，若只有一个匹配，则选择该函数，无视其他重载函数
* 如果有多个匹配，则匹配的函数进入重载集，此时对这些函数执行偏实例化，重载决议先根据一般重载函数规则决定，再根据偏序规则决定哪个更为“特化”
* 如果有多个或一个都没有最终被选择，则视为失败（前者为二义性，后者为没有该函数实例）