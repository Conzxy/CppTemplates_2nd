# 重载函数模板

考虑如下代码：

```cpp
template<class T>
int f(T){
    return 1;
}

template<class T>
int f(T*){
    return 2;
}
```

你要了解：这两个模板共同存在，且各自的实例化可以存在，尽管签名式一样

```cpp
int main(){
    std::cout<<f<int*>((int*)nullptr);	//call f<T>(T)
    std::cout<<f<int>((int*)nullptr);	//call f<T>(T*)
}
//12
```

稍作分析：

* `f<int*>`
  * `f<int*>(int*)`√
  * `f<int*>(int**)`

* `f<int>`
  * `f<int>(int)`
  * `f<int>(int*)`√

## 重载函数的选择决策

* 实参列表是否匹配，若只有一个匹配，则选择该函数
* 根据匹配是否需要函数声明中的参数进行实例化，来执行对应函数声明的偏实例化
* 如果有多个匹配，则匹配的函数进入重载集，重载决议先根据一般重载函数规则决定，再根据偏序规则决定哪个更为“特化”
* 如果最终有多个或零个被选择，则视为失败