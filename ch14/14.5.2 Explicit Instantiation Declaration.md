# 显式实例化声明

当有多个目标路径存在时，就会出现多余的隐式实例化，而在头文件中提供模板定义，使用显式实例化声明可以抑制该行为。

（我最懵逼的是我试了下面的几种情况，好像一个都不行。。全都需要提供显式实例化定义）

不过有以下情况是无法抑制的：

* 内联函数为了内联展开，仍能实例化
* 返回类型声明为`auto`或`decltype(auto)`的函数或变量，需要确定其推断类型仍能实例化
* 值为常量表达式的变量，为了能够计算它们的值仍能实例化
* 引用类型的变量。为了能够解析被引用的实体仍能实例化
* 类模板和别名模板。为检查其生成类型仍能实例化

```cpp
//t.hpp
template<typename T>
void f(){}

extern template void f<int>();			//提供声明但不提供定义
extern template void f<double>();

//t.cpp
template void f<int>();
template void f<double>();
```

显式实例化声明与其定义是成对的，缺了定义会引发连接错误（link error）

## 作用

当特化被用在许多翻译单元中，可以优化编译或连接时间。不同于手工实例化，不要求在需要新的特化时手动更新显式实例化定义列表，且可以在任何情况下作为一种优化引入。

但是，因为有些隐式实例化是无法避免的，相比手工实例化效果没那么显著，并且模板定义也会作为头文件的一部分被解析